<!DOCTYPE html>
<html>
  <head>
    <script src="libs/p5.min.js"></script>
    <script src="libs/p5.dom.min.js"></script>
    <script src="libs/three.min.js"></script>
    <script src="libs/regression.min.js"></script>
    <script src="interpolated_spheres.js"></script>

    <style>
    			body {
    				color: #ffffff;
    				font-family:Monospace;
    				font-size:13px;
    				text-align:center;
    				font-weight: bold;
    				background-color: #000000;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 0px; width: 100%;
    				padding: 5px;
    			}
    			a {
    				color: #ffffff;
    			}
    		</style>

  </head>


  <body>

	   <div id="container"></div>
     <div id="p5container"></div>


		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main()	{
				vUv = uv;
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec2 vUv;
			uniform float time;
      vec2 resolution = vec2(1920, 1080);

      const float maxDistance = 4.0;


//Signed distance function for a sphere centered at the origin, returns distance from the surface
float sphere(vec3 p, float r){
    //p.x += 0.2*sin(time);
    //r += 0.2*sin(time*2.0);
    //for any given point p in 3D space, length(p) is that point's Euclidean distance
    //from the origin (0, 0, 0). Its difference with r is that point's distance
    //from the sphere's surface: >0 if it's outside the sphere, <0 if it's inside the sphere
    //and 0 if it's exactly on the surface.
    return length(p)-r;
}

//Defines the general scene by testing each 3D point for intersection with
//the scene's objects.
float map(vec3 p){
   // p = mod(p*2.0*mouse.x, vec3(1.0));

    return sphere(p, 1.0);
}

//The marching function itself: takes a starting position and a direction vector
//and iterates from the position along the direction in ever-decreasing steps,
//until it either hits an object in the scene or it shoots off into the distance.
float march(vec3 rayOrigin, vec3 rayDirection){
    //Stop threshold that determines how close to an object is
    //close enough in order to call it a hit.
    float stopThresh = 0.05;
    //End threshold determines how far to travel before we give up and
    //return a "no hit" for that particular ray.
    float endThresh = maxDistance;
    //
    float currDistToObject = 0.0;
    float distTravelledSoFar = 0.0;


    for(int i = 0; i < 64; i++){
        currDistToObject = map(rayOrigin + distTravelledSoFar*rayDirection);

        if(currDistToObject < stopThresh || distTravelledSoFar >= endThresh)
            return distTravelledSoFar;

        distTravelledSoFar += currDistToObject * 0.1;
    }

    return distTravelledSoFar;
}


//The final colour that will be sent to every pixel

vec3 objectColor(vec3 p){
    return vec3(0.5+0.5*sin(p.x*30.0), 0.2, 0.7);
}

//The main function that controls what part of the shader gets displayed
void main(){
    vec2 q = gl_FragCoord.xy/resolution.xy;
    vec2 p = 2.0*q - 1.0;
    p.x *= resolution.x/resolution.y;

    //p = mod(p, vec3(1.0));

    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);
    vec3 rayDirection = vec3(p, 1.0);

    vec3 backgroundColor = vec3(1.0, 0.3, 0.4);

    float distanceUntilHit = march(rayOrigin, rayDirection);

    vec3 col = backgroundColor;

    if(distanceUntilHit > maxDistance){
        gl_FragColor = vec4(backgroundColor, 1.0);
        return;
    } else {

        vec3 surfacePos = rayOrigin + distanceUntilHit * rayDirection;

        col = objectColor(surfacePos);
        }

    gl_FragColor = vec4(col, 1);

}
		</script>

  </body>
</html>
