<!DOCTYPE html>
<html>
  <head>
    <script src="libs/p5.min.js"></script>
    <script src="libs/p5.dom.min.js"></script>
    <script src="libs/three.min.js"></script>
    <script src="libs/regression.min.js"></script>
    <script src="interpolated_spheres.js"></script>
    <script src="util.js"></script>

    <style>
    			body {
    				color: #ffffff;
    				background-color: #000000;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 0px; width: 100%;
    				padding: 0px;
    			}
    		</style>

  </head>


  <body>

	  <div id="container"></div>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main()	{
				vUv = uv;
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec2 vUv;
      uniform vec2 resolution;
			uniform float time;
      uniform float coeffs[8];

      const float PI = 3.14159265359;
      const float TWO_PI = 6.28318530718;

      const float maxDistance = 4.0;

      float sphere(vec3 p, float r){
          return length(p)-r;
      }

      float map(vec3 p){
          float x = atan(p.y, p.x);
          x = 1.0 - (x / TWO_PI); //normalize between 0 and 1

          float freq = 2.0;//+ (3.0*mod(time, 5.0) / 5.0);
          x = fract(x * freq);
          //x = fract(2.0*x);
          //float polyOut = (coeffs[3])*pow(x, 3.0) + coeffs[2]*pow(x, 2.0) + coeffs[1]*x + coeffs[0];

          float polyOut = (coeffs[7]*pow(x, 7.0) + coeffs[6]*pow(x, 6.0) + coeffs[5]*pow(x, 5.0) + coeffs[4]*pow(x, 4.0) + coeffs[3]*pow(x, 3.0) + coeffs[2]*pow(x, 2.0) + coeffs[1]*x + coeffs[0]);

          //float polyOut = 10.0*sin(time) * (coeffs[7]*pow(x, 7.0) + coeffs[6]*pow(x, 6.0) + coeffs[5]*pow(x, 5.0) + coeffs[4]*pow(x, 4.0) + coeffs[3]*pow(x, 3.0) + coeffs[2]*pow(x, 2.0) + coeffs[1]*x + coeffs[0]);
          //float s = cos(x*2.0 * TWO_PI);
          float r = 0.5;
          r += 0.6*clamp(polyOut, -0.5, 1.5);
          return sphere(p, r);
      }

      float march(vec3 rayOrigin, vec3 rayDirection){
          float stopThresh = 0.05;

          float endThresh = maxDistance;

          float currDistToObject = 0.0;
          float distTravelledSoFar = 0.0;
          for(int i = 0; i < 64; i++){
              currDistToObject = map(rayOrigin + distTravelledSoFar*rayDirection);

              if(currDistToObject < stopThresh || distTravelledSoFar >= endThresh)
                  return distTravelledSoFar;

              distTravelledSoFar += currDistToObject * 0.1;
          }
          return distTravelledSoFar;
      }


      vec3 objectColor(vec3 p){
          return vec3(0.5+0.5*sin(p.x*30.0), 0.2, 0.7);
      }

      void main(){

          vec2 q = gl_FragCoord.xy/resolution.xy;
          vec2 p = 2.0*q - 1.0;
          p.x *= resolution.x/resolution.y;

          vec3 rayOrigin = vec3(0.0, 0.0, -3.0);
          vec3 rayDirection = vec3(p, 1.0);

          // vec3 backgroundColor = vec3(1.0, 0.3, 0.4);
          vec3 backgroundColor = vec3(0.0);


          float x = q.x;

          //float polyOut = 10.0*sin(time) * (coeffs[7]*pow(x, 7.0) + coeffs[6]*pow(x, 6.0) + coeffs[5]*pow(x, 5.0) + coeffs[4]*pow(x, 4.0) + coeffs[3]*pow(x, 3.0) + coeffs[2]*pow(x, 2.0) + coeffs[1]*x + coeffs[0]);
          // backgroundColor += 0.3*polyOut;
          float distanceUntilHit = march(rayOrigin, rayDirection);

          vec3 col = backgroundColor;

          if(distanceUntilHit < maxDistance){
            vec3 surfacePos = rayOrigin + distanceUntilHit * rayDirection;
            col = objectColor(surfacePos);
          }

          gl_FragColor = vec4(col, 1);
      }
		</script>

  </body>
</html>
